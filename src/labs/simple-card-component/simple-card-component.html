<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../../bower_components/codelab-components/google-codelab-elements.html">

<dom-module id="codelab-simple-card-component">
    <template>
        <google-codelab title="Simple Card Component"
                        feedback-link="https://github.com/the-guide/bbconf2017-workshop-webcomponents/issues"
                        environment="web"
                        last-updated="2017-11-05">
            <google-codelab-step label="Introduction" duration="1">
                <h2><strong>Simple card component</strong></h2>

                <p>
                    For our next exercise we start with creating a small very basic component that can be the basis of
                    several end-customer components. When we have created this basic component we are going to extend it.
                </p>

                <p>
                    The basic component we are going to create is a card-component. It is commonly used on websites as a
                    small panel with a summary of another page and a link to that page. It often has a header and an image.
                </p>

                <h2><strong>What You'll Learn</strong></h2>

                <ul class="checklist">
                    <li>Using ES2015 class syntax to build a web component</li>
                    <li>Using Lit-Html to create templates using template literals</li>
                    <li>Extend a component</li>
                    <li>Add extra styling and functionality to a extended component</li>
                </ul>

                <h2><strong>What you'll need</strong></h2>

                <ul>
                    <li>Chrome 52 or above</li>
                    <li>Your favorite text editor</li>
                    <li>Basic knowledge of HTML, CSS, JavaScript, and Chrome DevTools</li>
                </ul>
            </google-codelab-step>
            <google-codelab-step label="Getting set up" duration="5">
                <h2><strong>Project Set Up</strong></h2>

                <p>
                    Fire up a code editor, and create three files <code>index.html</code>,
                    <code>simple-card.html</code> and <code>simple-card.js</code>.
                </p>

                <h3>demo/index.html</h3>

                <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Simple card component&lt;/title&gt;

        &lt;style&gt;
          body {
            width: 90%;
            max-width: 980px;
            background-color: #f5f5f5;
            margin: 0 auto 32px;
          }
        &lt;/style&gt;

    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Example page of the simple-card&lt;/h1&gt;
      &lt;h2&gt;An basic example&lt;/h2&gt;

    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

                <h3>simple-card.html</h3>

                <pre>
<code>
&lt;link rel="import" href="../bbconf2017-lithtml/bbconf2017-lit-element.html"&gt;
&lt;script src="simple-card.js"&gt;&lt;/script&gt;

</code></pre>
                <h3>simple-card.js</h3>

                <pre>
<code>
class SimpleCard extends HTMLElement {
    connectedCallback() {
        console.log('simple-card element added to the DOM!');
      }
    }
customElements.define('simple-card',SimpleCard);

</code></pre>

                <h3>Using the <code>simple-card</code> component</h3>

                <p>To employ <code>&lt;simple-card&gt;</code>, you need to:</p>

                <ol type="1" start="1">
                    <li>Use an <a href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/" target="_blank">HTML
                        Import</a> to load it in <code>demo/index.html</code>.
                    </li>
                    <li>Declare an instance of the element inside the <code>body</code>.</li>
                </ol>

                <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0,minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title>Simple-card-component&lt;/title&gt;
        &lt;link rel="import" href="../simple-card.html"&gt;

        &lt;style&gt;
          body {
            width: 90%;
            max-width: 980px;
            background-color: #f5f5f5;
            margin: 0 auto 32px;
          }
        &lt;/style&gt;

    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Example page of the simple-card&lt;/h1&gt;
      &lt;h2&gt;An basic example&lt;/h2&gt;

      &lt;simple-card&gt;&lt;/simple-card&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

                <h3>Preview the component</h3>

                <p>
                    Just open the <code>index.html</code> page in the browser, open the developer tools a look at the
                    <code>Console</code> tab where you should see:
                </p>

                <p style="display:flex; justify-content: center; align-items: center;">
                    <img src="[[rootPath]]images/labs/web-components-basics/console-log.png"></p>
            </google-codelab-step>
            <google-codelab-step label="Introducing Custom Elements" duration="5">
                <h2>Adding litHTML</h2>

                <p>
                    <a href="https://github.com/PolymerLabs/lit-html"
                       target="_blank">Lit-HTML</a>
                    lets you write HTML templates with JavaScript template literals, and efficiently render and re-render those templates to DOM.
                    lit-html provides two main exports:
                    <ul>
                        <li>html: A JavaScript template tag used to produce a TemplateResult, which is a container for a template, and the values that should populate the template.</li>
                        <li>render(): A function that renders a TemplateResult to a DOM container, such as an element or shadow root.</li>
                    </ul>
                    We prepared a Lit-HTML component that we can use.
                <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {


  connectedCallback() {
    console.log('simple-card element added to the DOM!');
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>
                <h3>bower.json</h3>
                <p>
                  Now that we use the Bbconf-lit-Element to extend we have to set this element as
                  a dependency. Let's create a bower.json containing it.
                </p>

                <pre>
<code>
{
  "name": "simple-card",
  "main": "simple-card.html",
  "dependencies": {
    "bbconf2017-lithtml": "https://github.com/The-Guide/bbconf2017-lithtml.git"
  }
}
</code></pre>
            </google-codelab-step>
            <google-codelab-step label="Creating HTML Templates with Lit-HTML" duration="5">
                <aside class="callout">
                  <p>
                    <strong>Lit-HTML</strong> has 4 main goals:
                    <ol>
                      <li>Efficient updates of previously rendered DOM.</li>
                      <li>Expressiveness and easy access to the JavaScript state that needs to be injected into DOM.</li>
                      <li>Standard JavaScript without required build steps, understandable by standards-compliant tools.</li>
                      <li>Very small size.</li>
                    </ol>
                  </p>
                </aside>

                <h2><strong>How it works</strong></h2>

                <p>
                    <code>lit-html</code> utilizes some unique properties of HTML <code>&lt;template&gt;</code> elements and JavaScript template literals. So it's helpful to understand them first.
                </p>
                   <h3>Tagged Template Literals</h3>
                <p>
                    A JavaScript template literal is a string literal that can have other JavaScript expressions embedded in it:
                </p>
               <code>
                   `My name is ${name}.`
               </code>
                <p>A tagged template literal is prefixed with a special template tag function:</p>
              <code>
                  let name = 'Monica';
                  tag`My name is ${name}.`
              </code>

                <p>
                    Tags are functions of the: <code>tag(strings, ...values)</code>, and <code>strings</code> is an immutable array of the literal parts, and values are the results of the embedded expressions.
                    In the preceding example, <code>strings</code> would be <code>['My name is ', '.']</code>, and values would be <code>['Monica']</code>.
                </p>

                <pre>
<code>
&lt;template id="mytemplate"&gt;
    &lt;img src="" alt="great image"&gt;
    &lt;div class="comment"&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre>

                <h2><strong>HTML<code>&lt;template&gt;</code> Elements</strong></h2>

                <p>
                    A <code>&lt;template&gt;</code> element is an inert tree of DOM (script don't run, images don't load,
                    custom elements aren't upgraded, etc) that can be efficiently cloned. It's usually used to tell the
                    HTML parser that a section of the document must not be instantiated when parsed,
                    but by code at a later time, but it can also be created imperatively with <code>createElement</code> and <code>innerHTML</code>.
                </p>

                <h3>Template Creation</h3>

                <p>
                    The first time <code>html</code> is called on a particular template literal
                    it does one-time setup work to create the template. It joins all the string parts
                    with a special placeholder, <code>"{{}}"</code>, then creates a <code>&lt;template&gt;</code>
                    and sets its <code>innerHTML</code> to the result. Then it walks the template's DOM and
                    extracts the placeholder and remembers their location.
                </p>
                <p>
                    Every call to <code>html</code> returns a <code>TemplateResult</code> which contains
                    the template created on the first call, and the expression values for the current call.
                </p>

                <h3>Template rendering</h3>

                <p>
                    <code>render()</code> takes a <code>TemplateResult</code> and renders it to a DOM container.
                    On the initial render it clones the template, then walks it using the remembered placeholder positions, to create <code>Part</code>s.
                </p>
                <p>
                    A<code>Part</code> is a "hole" in the DOM where values can be injected.
                    <code>lit-html</code> includes two type of parts by default: <code>NodePart</code> and <code>AttributePart</code>,
                    which let you set text content and attribute values respectively.
                    The <code>Part</code>s, container, and template they were created from are
                    grouped together in an object called a <code>TemplateInstance</code>.
                </p>
                <p>
                    Rendering can be customized by providing alternate <code>render()</code>
                    implementations which create different kinds of <code>TemplateInstances</code> and <code>Part</code>s,
                    like <code>PropertyPart</code> and <code>EventPart</code> included in <code>lib/lit-extended.ts</code> which
                    let templates set properties and event handlers on elements.
                </p>
                <h2>What are we creating</h2>

                <p>
                    We are going to make a simple card webcomponent. It should have a header,
                    body and a footer. Let's start with the header. It should be a template with a slot.
               </p>
         <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {

  get headerTemplate() {
    return html`
      &lt;header id="header"&gt;
        &lt;slot name="header" id="headerslot"&gt;&lt;/slot&gt;
      &lt;/header&gt;
  `}
  connectedCallback() {
    console.log('simple-card element added to the DOM!');
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>
              <p>
                Let's also create a body and footer template in the same way.
              </p>
              <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {

  get headerTemplate() {
    return html`
      &lt;header id="header"&gt;
        &lt;slot name="header" id="headerslot"&gt;&lt;/slot&gt;
      &lt;/header&gt;
  `;
  }
  get bodyTemplate() {
    return html`
      &lt;div id="body"&gt;
        &lt;slot id="bodyslot"&gt;&lt;/slot&gt;
      &lt;/div&gt;
  `;
  }
  get footerTemplate() {
    return html`
      &lt;footer id="footer"&gt;
        &lt;slot name="footer" id="footerslot"&gt;&lt;/slot&gt;
      &lt;/footer&gt;
  `;
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>
              <h3>Show it in the component</h3>

              <p>
                We want to see if our templates work. Let's put some content in the card.
              </p>
              <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0,minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title>Simple-card-component&lt;/title&gt;
        &lt;link rel="import" href="../simple-card.html">

        &lt;style&gt;
          body {
            width: 90%;
            max-width: 980px;
            background-color: #f5f5f5;
            margin: 0 auto 32px;
          }
        &lt;/style&gt;

    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Example page of the simple-card&lt;/h1&gt;
      &lt;h2&gt;An basic example&lt;/h2&gt;

      &lt;simple-card&gt;
       &lt;h3 slot="header"&gt;Title&lt;/h3&gt;
        &lt;div&gt;
          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis varius quam quam.
        &lt;/div&gt;
        &lt;div slot="footer"&gt;Footer&lt;/div&gt;
      &lt;/simple-card&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

            </google-codelab-step>
            <google-codelab-step label="Rendering and styling" duration="5">
              <h2>Render the templates</h2>

              <p>
                Out lit-element provides a <code>render()</code> to render the templates. Let's add them in the component.
              </p>
              <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {
  get headerTemplate() {
    return html`
      &lt;header id="header"&gt;
        &lt;slot name="header" id="headerslot"&gt;&lt;/slot&gt;
      &lt;/header&gt;
  `;
  }
  get bodyTemplate() {
    return html`
      &lt;div id="body"&gt;
        &lt;slot id="bodyslot"&gt;&lt;/slot&gt;
      &lt;/div&gt;
  `;
  }
  get footerTemplate() {
    return html`
      &lt;footer id="footer"&gt;
        &lt;slot name="footer" id="footerslot"&gt;&lt;/slot&gt;
      &lt;/footer&gt;
  `;
  }
  render() {
    return html`
      ${this.headerTemplate}
      ${this.bodyTemplate}
      ${this.footerTemplate}
    `;
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>

                <h2>Styling template</h2>

                <p>
                  Our card shows the content but is still unstyled. Let's add some styling. In your <code>simple-card</code>
                  add a styling template the same way you created the other templates.
                  It should contain a style tag and some basic styling on the <code>:host</code> element.

                <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {
 get styleTemplate() {
    return html`
     &lt;style&gt;
        :host {
          background: #fff;
          border-radius: 4px;
          box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
          0 1px 5px 0 rgba(0, 0, 0, 0.12),
          0 3px 1px -2px rgba(0, 0, 0, 0.2);
          position: relative;
          display: block;
          box-sizing: border-box;
          line-height: 1.5;
          font-weight: normal;
          width: 100%;
        }
      &lt;/style&gt;
    `;
  }

 ...

  render() {
    return html`
      ${this.styleTemplate}
      ${this.headerTemplate}
      ${this.bodyTemplate}
      ${this.footerTemplate}
    `;
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>

                <p>
                    Add now some styling on the header, body and footer:
                </p>
<pre><code>
get styleTemplate() {
 return html`
     &lt;style&gt;

    ...

    #header ::slotted(*),
    #body ::slotted(*),
    #footer ::slotted(*){
       padding: 24px 24px;
    }
    #header {
      color: inherit;
    }
    #header ::slotted(h1),
    #header ::slotted(h2),
    #header ::slotted(h3),
    #header ::slotted(h4),
    #header ::slotted(h5),
    #header ::slotted(h6) {
      margin-top: 0 !important;
      margin-bottom: 0 !important;
    }

    ...

  &lt;/style&gt;
`;
</code></pre>
              <p>
                Check the differences in the browser.
              </p>
            </google-codelab-step>
            <google-codelab-step label="Extending simple-card" duration="6">
                <h2><strong>Extending</strong></h2>

                <p>
                  We have a very simple card component. It has some very generic features. Imagine that we
                  want a specific card with a custom footer. How can we create that from the simple-card?
                  It is easy, we can <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends" target="_blank">extend</a> the simple card.
                </p>

                <p>
                  We are now creating a new component, the extended-card. Create <code>extended-card.html</code> and <code>extended-card.js</code>.
                </p>
                <h3>extended-card.html</h3>

                <pre>
<code>
&lt;link rel="import" href="bower_components/simple-card/simple-card.html"&gt;
&lt;script src="extended-card.js"&gt;&lt;/script&gt;
</code></pre>
              <h3>extended-card.js</h3>
              <pre>
<code>
class ExtendedCard extends SimpleCard {
 }

customElements.define('extended-card', ExtendedCard);
</code></pre>

                <p>
                    First, we want to add styling to the simple-card. We want to make the heading text
                  orangered and increase the fontsize. We want to use Roboto font. We want to keep the styling from <code>simple-card</code>.
                </p>
              <h3>extended-card.js</h3>
<pre>
<code>
  class ExtendedCard extends SimpleCard {
    get styleTemplate() {
      return html`
          ${super.styleTemplate}
          &lt;style&gt;
          :host {
            font-family: Roboto;
          }
          #header {
            color: orangered;
            font-size: 1.4em;

          }

          &lt;/style&gt;
        `;
    }
  }

  customElements.define('extended-card', ExtendedCard);
</code></pre>

                <p>Create an index.html to view the component.
                </p>
                <h3>Index.html</h3>
                <pre>
<code>
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;Extended-card Demo&lt;/title&gt;
  &lt;script src="../../webcomponentsjs/webcomponents-lite.js">&lt;/script&gt;

  &lt;link rel="import" href="../extended-card.html"&gt;

    &lt;/head&gt;
    &lt;body unresolved style="width: 90%; max-width: 980px; margin:0 auto;"&gt;

    &lt;h1 class="sr-only"&gt;Example page of the extended-card&lt;/h1&gt;

  &lt;h2 class="font-b-xl"&gt;An basic example&lt;/h2&gt;

  &lt;extended-card last-updated="6"&gt;
    &lt;h3 slot="header"&gt;Title&lt;/h3&gt;
    &lt;div&gt;
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis varius quam quam. Praesent gravida urna id
        nunc luctus, nec varius tortor tristique. Mauris non sem vel magna consectetur sodales. Aenean ut urna
        sodales, auctor elit condimentum, cursus neque. Sed quam mauris, ultricies ac congue ut, volutpat
        volutpat dui. Quisque sagittis diam et justo fringilla condimentum. Cras ut dignissim dolor, nec
        efficitur mi. Praesent vitae consectetur odio. Donec lectus nulla, tristique eget lacinia consequat,
        porttitor in arcu. Fusce mattis nec leo nec vulputate. In hac habitasse platea dictumst.
  &lt;/div&gt;

  &lt;/extended-card&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>


            </google-codelab-step>
            <google-codelab-step label="Create custom footer" duration="6">


                <h2><strong>Create a custom footer</strong></h2>

                <p>
                  This card element we are creating should have a fixed footer like <a href="https://v4-alpha.getbootstrap.com/components/card/" target="_blank">this (scroll down to card groups)</a> bootstrapped card footer.
                  The background color should be light grey and the text should be centered. Please create a new <code>footerTemplate</code> with the text "Last updated 5 minutes ago" and add styles too. Please add this styles:
                <pre>
<code> #footer {
padding: calc(var(--spacer-vertical, 8px) * 3) calc(var(--spacer-horizontal, 8px) * 3);
border-top: 1px solid var(--divider-color, #d5d5d5);
background-color: #f2f2f2;
font-size: 0.9em;
text-align: center;
color: #8c8c8c;
}</code>
            </pre>
                <h3>extended-card.js</h3>
                <pre>
<code>
  get footerTemplate() {
    return html`
    &lt;footer id="footer"&gt;
    Last updated 5 mins ago
    &lt;/footer&gt;
    `;}
  }
</code></pre>

                <aside class="callout">
                    <p>
                        Remove the outer <code>div</code> with the <code>greeter-frame</code> class and its associated
                        styling.
                    </p>
                </aside>

                <ul>
                    <li>
                        We set <code>all: initial</code> to reset all global style values so that they don’t affect our
                        element’s styles. Note that this should be the first property that you set in your CSS rule,
                        otherwise what follows could be reset too.
                    </li>
                    <li>
                        By default, custom elements are set to <code>display: inline</code>, so here we specify that it
                        should be <code>display: block</code> instead.
                    </li>
                    <li>
                        As you can see, the <code>:host</code> selector can also be used as a function to select only
                        the element if it matches the provided selector. We use that here to set <code>display:
                        none</code> on the element if has the hidden attribute.
                    </li>
                    <li>
                        We also use a new CSS property, <code>contain</code>, to hint to the CSS engine that the styles
                        are contained
                        and independent. This can help with layout performance in the browsers that support it.
                    </li>
                </ul>

                <p>
                    <strong>Note</strong> that if a custom element is styled externally by the user of the element with
                    something like this…
                </p>

                <pre>
<code>
random-greeter {
  background: none;
}
</code></pre>

                <p>
                    …the external styles will always win if they collide with the ones provided with <code>:host</code>.
                    So in that case, our element wouldn’t have its background color anymore.
                </p>

                <h2><strong>Theming Using <code>:host-context</code></strong></h2>

                <p>
                    We can also use a <code>:host-context()</code> selector that will select our custom element only if
                    it or any of its ancestors match the provided selector. This makes it really easy to style your
                    element differently if, say, the element has the <code>dark</code> or <code>light</code> class:
                </p>

                <pre>
<code>
:host-context(.dark) {
    background-color: #e65c00;
}

:host-context(.light) {
    background-color: #e65c00;
}
</code></pre>

                <h2><strong>Style Hooks</strong></h2>

                <p>
                    So far we’ve seen how we can easily style a custom element from within, but what if we want to let
                    the user of the element customize the styles without having to modify the element? This is where
                    <code>CSS custom properties come</code> in.
                </p>

                <p>
                    In <code>random-greeter</code>' element’s style definition, you’d use the custom properties like
                    this:
                </p>

                <pre>
<code>
:host {
    ...
    background-color: var(--var-bg-color, #FF6600);
    ...
}

...

h1 {
    ...
    color: var(--var-color, #ffffff);

    @apply --greeter-styles;
}
</code></pre>

                <p>
                    With this in place, our default colors will be used if variables are not defined, and now the colors
                    can be customized in page’s style using something like this:
                </p>

                <pre>
<code>
random-greeter {
    --var-bg-color: navy;
    --var-color: green;

    --greeter-styles: {
        font-family: "Bauhaus 93";
        font-size: 40px;
        border: dotted 5px yellow;
    }
}
</code></pre>

                <h2><strong>Styling distributed nodes</strong></h2>

                <p>
                    <code>::slotted(&lt;compound-selector&gt;)</code> matches nodes that are distributed into a
                    &lt;slot&gt;.
                </p>

                <pre>
<code>
::slotted(marquee) {
    color: yellow;
    font-size: 20px;
}

.bottom::slotted(*) {
    text-align: left;
    color: #ffffff;
}
</code></pre>
            </google-codelab-step>
            <google-codelab-step label="xx" duration="6">
                <aside class="note">
                    <p>
                        We covered the basics of creating custom elements using Web Component specs, but our simple
                        custom element is not yet production-ready because of the use of new JavaScript features and the
                        fact that <strong>Custom Elements</strong> and <strong>Shadow DOM</strong> are not supported in
                        all popular browsers yet.
                    </p>
                </aside>

                <p>
                    In this step, we’ll quickly go over the steps to transpile our custom element code to be compatible
                    with ES5 and to include the necessary Web Components polyfills.
                </p>

                <h2><strong>Transpiling</strong></h2>

                <p>
                    <code>random-greeter</code> element code contains ES6 classes and string literals and arrow
                    functions. These features are great to use at author-time, but the code has to be transpiled using a
                    tool like Babel so that it can run in browsers that only understand ES5 code. We’ll go ahead and use
                    babel-cli and the babel-preset-es2015 preset do to just that.
                </p>

                <p>
                    If your project doesn’t have a <code>package.json</code> file just yet, go ahead an create one using
                    either <code>npm</code> or <code>Yarn</code>. This will allow you to install the necessary
                    packages:
                </p>

                <pre>
<code>
$ npm init

# or, using Yarn
$ yarn init
</code></pre>

                <p>
                    Once this is done, you can go ahead and install the necessary packages:
                </p>

                <pre>
<code>
$ npm install babel-cli babel-preset-es2015 crisper vulcanize rimraf --save-dev

# or, using Yarn
$ yarn add babel-cli babel-preset-es2015 crisper vulcanize rimraf --dev
</code></pre>

                <p>
                    We’ll output our transpiled code into a <code>dist</code> folder, so you can go ahead and create
                    that folder at the root of your project. Now you can some scripts script to the
                    <strong>package.json</strong> file that runs Babel with the es2015 preset and outputs the result in
                    the <strong>dist</strong> folder:
                </p>

                <pre>
<code>
{
    ...
  "scripts": {
    "clean": "rimraf dist",
    "prebuild": "npm run clean -s && mkdir dist",
    "build:vulcanize": "vulcanize random-greeter.html --inline-script --inline-css | crisper -h dist/random-greeter.html -j dist/random-greeter.js",
    "build": "npm run build:vulcanize && babel --presets es2015 dist/random-greeter.js --out-file dist/random-greeter.js"
  },
  "devDependencies": {
    "babel-cli": "^6.26.0",
    "babel-preset-es2015": "^6.24.1",
    "crisper": "^2.1.1",
    "rimraf": "^2.6.2",
    "vulcanize": "^1.16.0"
  }
}
</code></pre>

                <p>
                    Now you can go ahead and run the transpiling:
                </p>

                <pre>
<code>
$ npm run build

# or, using Yarn
$ yarn build
</code></pre>

                <h2><strong>Polyfills</strong></h2>

                <p>
                    Polyfills are small plugins that implement a feature to replace a missing native implementation for
                    browsers that don’t have support yet. For Web Components, we’ll need polyfills for Custom Elements,
                    Shadow DOM and the template element.
                </p>

                <p>
                    There’s also a loader available, <code>webcomponents-loader.js</code>, that will perform some
                    feature detection and include the necessary polyfills on the fly. Using the loader is probably the
                    simplest way to get everything working, and this is what we’ll use here for our example.
                </p>

                <p>
                    Custom elements need to be defined using ES6 classes that extend <code>HTMLElement</code>, but now
                    we’re using transpiled code that has the class syntax stripped away. We’ll need to use a file called
                    <code>custom-elements-es5-adapter.js</code> to fix that for us.
                </p>

                <p>
                    Simply install the <code>@webcomponents/webcomponentsjs</code> package into your project using
                    <code>npm</code> or <code>yarn</code>. This will install the necessary files in the node_modules
                    folder:
                </p>

                <pre>
<code>
$ npm install @webcomponents/webcomponentsjs --save

# or, using Yarn
$ yarn add npm install @webcomponents/webcomponentsjs
</code></pre>

                <p>
                    Now, in your page’s head, include <code>custom-elements-es5-adapter.js</code> and
                    <code>webcomponents-loader.js</code>:
                </p>

                <pre>
<code>
&lt;script src="node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js"&gt;&lt;/script&gt;
&lt;script src="node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"&gt;&lt;/script&gt;
</code></pre>

                <p>
                    The final step is only include the script for your transpiled custom element when the <code>WebComponentsReady</code>
                    event fires. That’s a custom event that gets fired by the loader when the necessary polyfills have
                    been loaded. We’ll simply create a <code>link</code> element, set its <code>rel</code> and <strong>src</strong>
                    property to the path of our transpiled custom element code and append it to the document’s head:
                </p>

                <pre>
<code>
window.addEventListener('WebComponentsReady', function () {
    var randomGreeterImport = document.createElement('link');
    randomGreeterImport.rel = 'import';
    randomGreeterImport.href = 'dist/random-greeter.html';
    document.head.appendChild(randomGreeterImport);
});
</code></pre>

                <p>
                    Here’s how our final <code>index.html</code> file looks like:
                </p>

                <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Web Component Basics&lt;/title&gt;

        &lt;script src="node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js"&gt;&lt;/script&gt;
        &lt;script src="node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"&gt;&lt;/script&gt;
        &lt;style&gt;
            h1 {
                color: #ff6600 !important;
            }

            random-greeter {
                --var-bg-color: navy;
                --var-color: green;

                --greeter-styles: {
                    font-family: "Bauhaus 93";
                    font-size: 40px;
                    border: dotted 5px yellow;
                }
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;random-greeter class="light"&gt;&lt;/random-greeter&gt;
        &lt;random-greeter class="dark"&gt;&lt;/random-greeter&gt;
        &lt;random-greeter&gt;
            &lt;marquee behavior="alternate" direction="right" slot="top"&gt;#BBConf rulz!!!&lt;/marquee&gt;
            &lt;ul&gt;
                &lt;li&gt;Something&lt;/li&gt;
                &lt;li&gt;More something&lt;/li&gt;
                &lt;li&gt;About&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/random-greeter&gt;

        &lt;script&gt;
            window.addEventListener('WebComponentsReady', function () {
                var randomGreeterImport = document.createElement('link');
                randomGreeterImport.rel = 'import';
                randomGreeterImport.href = 'dist/random-greeter.html';
                document.head.appendChild(randomGreeterImport);
            });
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
            </google-codelab-step>
            <google-codelab-step label="xx" duration="1">
                <p>
                    Custom elements allow you to extend HTML and define your own tags. They're an incredibly powerful
                    feature, but they're also low-level, which means it's not always clear how best to implement your
                    own element
                </p>

                <p>
                    Here is a checklist which breaks down the things we applied to create a well behaved custom element.
                </p>

                <ul class="checklist">
                    <li>Create a shadow root to encapsulate styles.</li>
                    <li>Create your shadow root in the constructor.</li>
                    <li>Place any children the element creates into its shadow root.</li>
                    <li>
                        Set a :host display style (e.g. block, inline-block, flex) unless you prefer the default of
                        inline.
                    </li>
                    <li>Add a :host display style that respects the hidden attribute.</li>
                    <li>
                        Always accept primitive data (strings, numbers, booleans) as either attributes or properties.
                    </li>
                    <li>
                        Aim to keep primitive data attributes and properties in sync, reflecting from property to
                        attribute, and vice versa.
                    </li>
                    <li>Aim to only accept rich data (objects, arrays) as properties.</li>
                    <li>Do not reflect rich data properties to attributes.</li>
                </ul>
            </google-codelab-step>
        </google-codelab>
    </template>
    <script>
        Polymer({
            is: 'codelab-simple-card-component',

            _twoWayBinding: function(value) {
                return '{{' + value + '}}';
            },

            _oneWayBinding: function(value) {
                return '[[' + value + ']]';
            }
        });
    </script>
</dom-module>
