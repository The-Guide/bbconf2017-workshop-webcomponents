<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../../bower_components/codelab-components/google-codelab-elements.html">

<dom-module id="codelab-simple-card-component">
    <template>
        <google-codelab title="Simple Card Component"
                        feedback-link="https://github.com/the-guide/bbconf2017-workshop-webcomponents/issues"
                        environment="web"
                        last-updated="2017-11-05">
            <google-codelab-step label="Introduction" duration="1">
                <h2><strong>Simple card component</strong></h2>

                <p>
                    For our next exercise we start with creating a small very basic component that can be the basis of
                    several end-customer components. When we have created this basic component we are going to extend it.
                </p>

                <p>
                    The basic component we are going to create is a card-component. It is commonly used on websites as a
                    small panel with a summary of another page and a link to that page. It often has a header and an image.
                </p>

                <h2><strong>What You'll Learn</strong></h2>

                <ul class="checklist">
                    <li>Using ES2015 class syntax to build a web component</li>
                    <li>Using Lit-Html to create templates using template literals</li>
                    <li>Extend a component</li>
                    <li>Add extra styling and functionality to a extended component</li>
                </ul>

                <h2><strong>What you'll need</strong></h2>

                <ul>
                    <li>Chrome 52 or above</li>
                    <li>Your favorite text editor</li>
                    <li>Basic knowledge of HTML, CSS, JavaScript, and Chrome DevTools</li>
                </ul>
            </google-codelab-step>
            <google-codelab-step label="Getting set up" duration="5">
                <!--<h2><strong>Install Tools</strong></h2>-->

                <!--<h2><strong>Project Set Up</strong></h2>-->

                <p>
                    Fire up a code editor, and create two files <code>index.html</code>,
                    <code>simple-card.html</code> and <code>simple-card.js</code>.
                </p>

                <h3>index.html</h3>

                <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Simple card component&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

                <h3>simple-card.html</h3>

                <pre>
<code>
&lt;link rel="import" href="../bbconf2017-lithtml/bbconf2017-lit-element.html"&gt;
&lt;script src="simple-card.js"&gt;&lt;/script&gt;

</code></pre>
                <h3>simple-card.js</h3>

                <pre>
<code>
class SimpleCard extends HTMLElement {
    connectedCallback() {
        console.log('simple-card element added to the DOM!');
      }
    }
customElements.define('simple-card',SimpleCard);

</code></pre>

                <h3>Using the <code>simple-card</code> component</h3>

                <p>To employ <code>&lt;simple-card&gt;</code>, you need to:</p>

                <ol type="1" start="1">
                    <li>Use an <a href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/" target="_blank">HTML
                        Import</a> to load it in <code>index.html</code>.
                    </li>
                    <li>Declare an instance of the element inside the <code>body</code>.</li>
                </ol>

                <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0,minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title>Simple-card-component&lt;/title&gt;
        &lt;link rel="import" href="simple-card.html">
    &lt;/head&gt;
    &lt;body&gt;
        &lt;simple-card&gt;&lt;/simple-card&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

                <h3>Preview the component</h3>

                <p>
                    Just open the <code>index.html</code> page in the browser, open the developer tools a look at the
                    <code>Console</code> tab where you should see:
                </p>

                <p style="display:flex; justify-content: center; align-items: center;">
                    <img src="[[rootPath]]images/labs/web-components-basics/console-log.png"></p>
            </google-codelab-step>
            <google-codelab-step label="Introducing Custom Elements" duration="5">
                <h2>Adding litHTML</h2>

                <p>
                    <a href="https://github.com/PolymerLabs/lit-html"
                       target="_blank">Lit-HTML</a>
                    lets you write HTML templates with JavaScript template literals, and efficiently render and re-render those templates to DOM.
                    lit-html provides two main exports:
                    <ul>
                        <li>html: A JavaScript template tag used to produce a TemplateResult, which is a container for a template, and the values that should populate the template.</li>
                        <li>render(): A function that renders a TemplateResult to a DOM container, such as an element or shadow root.</li>
                    </ul>
                    We prepared a Lit-HTML component that we can use.
                <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {


  connectedCallback() {
    console.log('simple-card element added to the DOM!');
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>
                <h3>bower.json</h3>
                <p>
                    Now that we use the Bbconf-lit-Element to extend we have to set this element as a dependency. Let's create a bower.json.
                </p>

                <pre>
<code>
{
  "name": "simple-card",
  "main": "simple-card.html",
  "dependencies": {
    "bbconf2017-lithtml": "https://github.com/The-Guide/bbconf2017-lithtml.git"
  },
  "devDependencies": {
    "iron-demo-helpers": "PolymerElements/iron-demo-helpers#^2.0.0",
    "web-component-tester": "Polymer/web-component-tester#^6.0.0",
    "webcomponentsjs": "webcomponents/webcomponentsjs#^1.0.0"
  }
}
</code></pre>
            </google-codelab-step>
            <google-codelab-step label="Creating HTML Templates with Lit-HTML" duration="5">
                <aside class="callout">
                    <p>
                        <strong>Lit-HTML</strong> has 4 main goals:
                        <ol>
                    <li>Efficient updates of previously rendered DOM.</li>
                    <li>Expressiveness and easy access to the JavaScript state that needs to be injected into DOM.</li>
                    <li>Standard JavaScript without required build steps, understandable by standards-compliant tools.</li>
                    <li>Very small size.</li>
                </ol>
                    </p>
                </aside>

                <h2><strong>How it works</strong></h2>

                <p>
                    <code>lit-html</code> utilizes some unique properties of HTML <code>&lt;template&gt;</code> elements and JavaScript template literals. So it's helpful to understand them first.
                </p>
                   <h3>Tagged Template Literals</h3>
                <p>
                    A JavaScript template literal is a string literal that can have other JavaScript expressions embedded in it:
                </p>
               <code>
                   `My name is ${name}.`
               </code>
                <p>A tagged template literal is prefixed with a special template tag function:</p>
              <code>
                  let name = 'Monica';
                  tag`My name is ${name}.`
              </code>

                <p>
                    Tags are functions of the: <code>tag(strings, ...values)</code>, and <code>strings</code> is an immutable array of the literal parts, and values are the results of the embedded expressions.
                    In the preceding example, <code>strings</code> would be <code>['My name is ', '.']</code>, and values would be <code>['Monica']</code>.
                </p>

                <pre>
<code>
&lt;template id="mytemplate"&gt;
    &lt;img src="" alt="great image"&gt;
    &lt;div class="comment"&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre>

                <h2><strong>HTML<code>&lt;template&gt;</code> Elements</strong></h2>

                <p>
                    A <code>&lt;template&gt;</code> element is an inert tree of DOM (script don't run, images don't load,
                    custom elements aren't upgraded, etc) that can be efficiently cloned. It's usually used to tell the
                    HTML parser that a section of the document must not be instantiated when parsed,
                    but by code at a later time, but it can also be created imperatively with <code>createElement</code> and <code>innerHTML</code>.
                </p>

                <h3>Template Creation</h3>

                <p>
                    The first time <code>html</code> is called on a particular template literal
                    it does one-time setup work to create the template. It joins all the string parts
                    with a special placeholder, <code>"{{}}"</code>, then creates a <code>&lt;template&gt;</code>
                    and sets its <code>innerHTML</code> to the result. Then it walks the template's DOM and
                    extracts the placeholder and remembers their location.
                </p>
                <p>
                    Every call to <code>html</code> returns a <code>TemplateResult</code> which contains
                    the template created on the first call, and the expression values for the current call.
                </p>

                <h3>Template rendering</h3>

                <p>
                    <code>render()</code> takes a <code>TemplateResult</code> and renders it to a DOM container.
                    On the initial render it clones the template, then walks it using the remembered placeholder positions, to create <code>Part</code>s.
                </p>
                <p>
                    A<code>Part</code> is a "hole" in the DOM where values can be injected.
                    <code>lit-html</code> includes two type of parts by default: <code>NodePart</code> and <code>AttributePart</code>,
                    which let you set text content and attribute values respectively.
                    The <code>Part</code>s, container, and template they were created from are
                    grouped together in an object called a <code>TemplateInstance</code>.
                </p>
                <p>
                    Rendering can be customized by providing alternate <code>render()</code>
                    implementations which create different kinds of <code>TemplateInstances</code> and <code>Part</code>s,
                    like <code>PropertyPart</code> and <code>EventPart</code> included in <code>lib/lit-extended.ts</code> which
                    let templates set properties and event handlers on elements.
                </p>
                <h2>What are we creating</h2>

                <p>
                    We are going to make a simple card webcomponent. It should have a header,
                    body and a footer. Let's start with the header. It should be a template with a slot.
               </p>
         <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {

  get headerTemplate() {
    return html`
      &lt;header id="header"&gt;
        &lt;slot name="header" id="headerslot"&gt;&lt;/slot&gt;
      &lt;/header&gt;
  `}
  connectedCallback() {
    console.log('simple-card element added to the DOM!');
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>
              <p>
                Let's also create a body and footer template in the same way.
              </p>
              <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {

  get headerTemplate() {
    return html`
      &lt;header id="header"&gt;
        &lt;slot name="header" id="headerslot"&gt;&lt;/slot&gt;
      &lt;/header&gt;
  `;
  }
  get bodyTemplate() {
    return html`
      &lt;main id="main"&gt;
        &lt;slot name="main" id="mainslot"&gt;&lt;/slot&gt;
      &lt;/main&gt;
  `;
  }
  get footerTemplate() {
    return html`
      &lt;footer id="footer"&gt;
        &lt;slot name="footer" id="footerslot"&gt;&lt;/slot&gt;
      &lt;/footer&gt;
  `;
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>
              <h3>Show it in the component</h3>

              <p>
                We want to see if our templates work. Let's put some content in the card.
              </p>
              <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0,minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title>Simple-card-component&lt;/title&gt;
        &lt;link rel="import" href="simple-card.html">
    &lt;/head&gt;
    &lt;body&gt;
        &lt;simple-card&gt;
         &lt;h3 slot="header"&gt;Title&lt;/h3&gt;
          &lt;div slot="main"&gt;
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis varius quam quam.
          &lt;/div&gt;
          &lt;div slot="footer"&gt;Footer&lt;/div&gt;
        &lt;/simple-card&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

            </google-codelab-step>
            <google-codelab-step label="Rendering and styling" duration="5">
              <h2>Render the templates</h2>

              <p>
                Out lit-element provides a <code>render()</code> to render the templates. Let's add them in the component.
              </p>
              <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {
  get headerTemplate() {
    return html`
      &lt;header id="header"&gt;
        &lt;slot name="header" id="headerslot"&gt;&lt;/slot&gt;
      &lt;/header&gt;
  `;
  }
  get bodyTemplate() {
    return html`
      &lt;main id="main"&gt;
        &lt;slot name="main" id="mainslot"&gt;&lt;/slot&gt;
      &lt;/main&gt;
  `;
  }
  get footerTemplate() {
    return html`
      &lt;footer id="footer"&gt;
        &lt;slot name="footer" id="footerslot"&gt;&lt;/slot&gt;
      &lt;/footer&gt;
  `;
  }
  render() {
    return html`
      ${this.headerTemplate}
      ${this.bodyTemplate}
      ${this.footerTemplate}
    `;
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>

                <h2>Styling template</h2>

                <p>
                  Our card shows the content but is still unstyled. Let's add some styling. In your <code>simple-card</code>
                  add a styling template the same way you created the other templates.
                  It should contain a style tag and some basic styling on the <code>:host</code>.
                  <pre>
              :host {
                background: #fff;
                border-radius: 4px;
                box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                            0 1px 5px 0 rgba(0, 0, 0, 0.12),
                            0 3px 1px -2px rgba(0, 0, 0, 0.2);
                position: relative;
                display: block;
                box-sizing: border-box;
                line-height: 1.5;
                font-weight: normal;
                width: 100%;
              }
            </pre>
                </p>

                <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {
 get styleTemplate() {
    return html`
     &lt;style&gt;
        :host {
          background: #fff;
          border-radius: 4px;
          box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
          0 1px 5px 0 rgba(0, 0, 0, 0.12),
          0 3px 1px -2px rgba(0, 0, 0, 0.2);
          position: relative;
          display: block;
          box-sizing: border-box;
          line-height: 1.5;
          font-weight: normal;
          width: 100%;
        }
      &lt;/style&gt;
    `;
  }

  get headerTemplate() {
    return html`
      &lt;header id="header"&gt;
        &lt;slot name="header" id="headerslot"&gt;&lt;/slot&gt;
      &lt;/header&gt;
  `;
  }
  get bodyTemplate() {
    return html`
      &lt;main id="main"&gt;
        &lt;slot name="main" id="mainslot"&gt;&lt;/slot&gt;
      &lt;/main&gt;
  `;
  }
  get footerTemplate() {
    return html`
      &lt;footer id="footer"&gt;
        &lt;slot name="footer" id="footerslot"&gt;&lt;/slot&gt;
      &lt;/footer&gt;
  `;
  }
  render() {
    return html`
      ${this.styleTemplate}
      ${this.headerTemplate}
      ${this.bodyTemplate}
      ${this.footerTemplate}
    `;
  }
}

// Register custom element definition using standard platform API
customElements.define('simple-card', SimpleCard);
</code></pre>

                <p>
                    Add now some styling on the header, main and footer:
                  <pre>
              #header ::slotted(*),
              #main ::slotted(*),
              #footer ::slotted(*){
                 padding: 24px 24px;
              }
              #header {
                color: inherit;
              }
              #header ::slotted(h1),
              #header ::slotted(h2),
              #header ::slotted(h3),
              #header ::slotted(h4),
              #header ::slotted(h5),
              #header ::slotted(h6) {
                margin-top: 0 !important;
                margin-bottom: 0 !important;
              }
            </pre>
                </p>

                <pre>
<code>
class SimpleCard extends Bbconf2017LitElement {
 get styleTemplate() {
    return html`
     &lt;style&gt;
        :host {
          background: #fff;
          border-radius: 4px;
          box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
          0 1px 5px 0 rgba(0, 0, 0, 0.12),
          0 3px 1px -2px rgba(0, 0, 0, 0.2);
          position: relative;
          display: block;
          box-sizing: border-box;
          line-height: 1.5;
          font-weight: normal;
          width: 100%;
        }
        #header ::slotted(*),
        #main ::slotted(*),
        #footer ::slotted(*){
           padding: 24px 24px;
        }
        #header {
          color: inherit;
        }
        #header ::slotted(h1),
        #header ::slotted(h2),
        #header ::slotted(h3),
        #header ::slotted(h4),
        #header ::slotted(h5),
        #header ::slotted(h6) {
          margin-top: 0 !important;
          margin-bottom: 0 !important;
        }
      &lt;/style&gt;
    `;
  }
</code></pre>
            </google-codelab-step>
            <google-codelab-step label="xxx" duration="6">
                <h2><strong>Introduction</strong></h2>

                <p>
                    Shadow DOM removes the brittleness of building web apps. The brittleness comes from the global
                    nature of HTML, CSS, and JS. For example, when you use a new HTML id/class, there's no telling if
                    it will conflict with an existing name used by the page. Subtle bugs creep up, CSS specificity
                    becomes a huge issue (!important all the things!), style selectors grow out of control, and
                    performance can suffer.
                </p>

                <p>
                    <strong>Shadow DOM fixes CSS and DOM</strong>. It introduces <strong>scoped styles</strong> to the
                    web platform. Without tools or naming conventions, you can <strong>bundle CSS with markup</strong>,
                    hide implementation details, and <strong>author self-contained components</strong> in vanilla
                    JavaScript.
                </p>

                <p>
                    Shadow DOM is designed as a tool for building component-based apps. Therefore, it brings solutions
                    for common problems in web development:
                </p>

                <ul>
                    <li>
                        <strong>Isolated DOM</strong>: A component's DOM is self-contained (e.g.
                        document.querySelector() won't return
                        nodes in the component's shadow DOM).
                    </li>
                    <li>
                        <strong>Scoped CSS</strong>: CSS defined inside shadow DOM is scoped to it. Style rules don't
                        leak out and page styles don't bleed in.
                    </li>
                    <li>
                        <strong>Composition</strong>: Design a declarative, markup-based API for your component.
                    </li>
                    <li>
                        <strong>Simplifies CSS</strong>: Scoped DOM means you can use simple CSS selectors, more generic
                        id/class names, and not worry about naming conflicts.
                    </li>
                    <li>
                        <strong>Productivity</strong>: Think of apps in chunks of DOM rather than one large (global)
                        page.
                    </li>
                </ul>


                <h2><strong>What is shadow DOM</strong></h2>

                <p>
                    Shadow DOM is just normal DOM with two differences:
                </p>

                <ol>
                    <li>how it's created/used and</li>
                    <li>how it behaves in relation to the rest of the page.</li>
                </ol>

                <p>
                    Normally, DOM nodes are created and appended as children of another element. With shadow DOM, a
                    create a scoped DOM tree that's attached to the element, but separate from its actual children. This
                    scoped subtree (named shadow tree) is created. The element it's attached to its shadow host.
                    Anything added in the shadow tree becomes local to the hosting element, including
                    <code>&lt;style&gt;</code>. This is how shadow DOM achieves CSS style scoping.
                </p>

                <h2><strong>Creating shadow DOM</strong></h2>

                <p>
                    A <strong>shadow root</strong> is a document fragment that gets attached to a “host” element. The
                    act of attaching a shadow root is how the element gains its shadow DOM. To create shadow DOM for an
                    element, call <code>element.attachShadow()</code>:
                </p>

                <pre>
<code>
const header = document.createElement('header');
const shadowRoot = header.attachShadow({mode: 'open'});
shadowRoot.innerHTML = '&lt;h1&gt;Hello Shadow DOM&lt;/h1&gt;'; // Could also use appendChild().

// header.shadowRoot === shadowRoot
// shadowRoot.host === header
</code></pre>

                <p>
                    Shadow DOM is particularly useful when creating custom elements. Use shadow DOM to compartmentalize
                    an element's HTML, CSS, and JS, thus producing a "web component".
                </p>

                <p>A custom element attaches shadow DOM to itself, encapsulating its DOM/CSS <code>this.attachShadow({mode:
                    'open'});</code></p>

                <h3>Applying to <code>random-greeter</code></h3>

                <p>
                    Before creating a shadow root for the <code>random-greeter</code> component let's simulate possible
                    conflicts.
                </p>

                <p>
                    Inside the <code>index.html</code> file add the following <code>style</code> block:
                </p>

                <pre>
<code>
&lt;style&gt;
    h1 {
        color: #ff6600 !important;
    }
&lt;/style&gt;
</code></pre>

                <p>
                    and refresh the browser. Is this something that could happen? Of course, it is. Now let's fix it by
                    creating a <code>shadow root</code>
                </p>

                <pre>
<code>
...
constructor() {
    ...

    this._root = this.attachShadow({"mode": "open"});
}

connectedCallback() {
    ...
    //this.appendChild($content);
    this._root.appendChild($content);

    //this._$greet = this.querySelector("#greet");
    this._$greet = this._root.querySelector("#greet");

    ...
}
</code></pre>

                <h2><strong>Composition and slots</strong></h2>

                <p>
                    Shadow DOM composes different DOM trees together using the <code>&lt;slot&gt;</code> element. Slots
                    are placeholders inside your component that users can fill with their own markup. By defining one or
                    more slots, you invite outside markup to render in your component's shadow DOM. Essentially, you're
                    saying "Render the user's markup over here".
                </p>

                <aside class="callout">
                    <p>
                        <strong>Note</strong>: Slots are a way of creating a "declarative API" for a web component.
                        They mix-in the user's DOM to help render the overall component, thus, composing different DOM
                        trees together.
                    </p>
                </aside>

                <p>
                    Elements are allowed to "cross" the shadow DOM boundary when a &lt;slot&gt; invites them in. These
                    elements are called <strong>distributed nodes</strong>. Conceptually, distributed nodes can seem a
                    bit bizarre. Slots don't physically move DOM; they render it at another location inside the shadow
                    DOM.
                </p>

                <p>
                    A component can define zero or more slots in its shadow DOM. Slots can be empty or provide fallback
                    content. If the user doesn't provide light DOM content, the slot renders its fallback content.
                </p>

                <p>
                    You can also create named slots. Named slots are specific holes in your shadow DOM that users
                    reference by name.
                </p>

                <pre>
<code>
&lt;!-- Default slot. If there's more than one default slot, the first is used. --&gt;
&lt;slot&gt;&lt;/slot&gt;

&lt;slot&gt;fallback content&lt;/slot&gt; &lt;!-- default slot with fallback content --&gt;

&lt;slot&gt; &lt;!-- default slot entire DOM tree as fallback --&gt;
  &lt;h2&gt;Title&lt;/h2&gt;
    &lt;summary&gt;Description text&lt;/summary&gt;
&lt;/slot&gt;

&lt;!-- Named slot use slot="title" when referencing--&gt;
&lt;slot name="title"&gt;&lt;/slot&gt;
</code></pre>

                <h3>Applying to <code>random-greeter</code></h3>

                <p>Let's add two slots to the <code>random-greeter</code> component, a named and a default one</p>

                <pre>
<code>
&lt;div class="greeter-frame"&gt;
    &lt;slot name="top"&gt;&lt;/slot&gt;
    &lt;h1 id="greet">&lt;/h1>
    &lt;slot class="bottom"&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>

                <p>Now in <code>index.html</code></p>

                <pre>
<code>
&lt;random-greeter&gt;
    &lt;marquee behavior="alternate" direction="right" slot="top"&gt;#BBConf rulz!!!&lt;/marquee&gt;
    &lt;ul&gt;
        &lt;li&gt;Something&lt;/li&gt;
        &lt;li&gt;More something&lt;/li&gt;
        &lt;li&gt;About&lt;/li&gt;
    &lt;/ul&gt;
&lt;/random-greeter&gt;
</code></pre>

                <h2><strong>Exercise</strong></h2>

                <p>Experiment with <code>slots</code></p>
            </google-codelab-step>
            <google-codelab-step label="xx" duration="6">
                <aside class="note">
                    <p>
                        Thanks to Shadow DOM, it’s very easy to style your Web Components using simple CSS selectors. In
                        this step we’ll cover a few extra styling options available to us to style custom elements. On
                        top of that, we’ll see how to allow the creation of styling hooks that make it easy for a custom
                        element’s user to customize the style from the outside.
                    </p>
                </aside>

                <h2><strong>Styling a Custom Element With <code>:host</code></strong></h2>

                <p>
                    The <code>:host</code> selector makes it easy to select and style the custom element itself, meaning
                    the shell of the element. Let’s add some styles to our <code>random-greeter</code> element:
                </p>

                <pre>
<code>
:host {
    all: initial;
    display: block;
    contain: content;
    text-align: center;
    padding: 20px;
    background-color: #FF6600;
    max-width: 500px;
    margin: 0 auto;
    border-radius: 8px;
    transition: transform .2s ease-out;
}
:host([hidden]) {
    display: none;
}
:host(:hover) {
    transform: scale(1.1);
}
</code></pre>

                <aside class="callout">
                    <p>
                        Remove the outer <code>div</code> with the <code>greeter-frame</code> class and its associated
                        styling.
                    </p>
                </aside>

                <ul>
                    <li>
                        We set <code>all: initial</code> to reset all global style values so that they don’t affect our
                        element’s styles. Note that this should be the first property that you set in your CSS rule,
                        otherwise what follows could be reset too.
                    </li>
                    <li>
                        By default, custom elements are set to <code>display: inline</code>, so here we specify that it
                        should be <code>display: block</code> instead.
                    </li>
                    <li>
                        As you can see, the <code>:host</code> selector can also be used as a function to select only
                        the element if it matches the provided selector. We use that here to set <code>display:
                        none</code> on the element if has the hidden attribute.
                    </li>
                    <li>
                        We also use a new CSS property, <code>contain</code>, to hint to the CSS engine that the styles
                        are contained
                        and independent. This can help with layout performance in the browsers that support it.
                    </li>
                </ul>

                <p>
                    <strong>Note</strong> that if a custom element is styled externally by the user of the element with
                    something like this…
                </p>

                <pre>
<code>
random-greeter {
  background: none;
}
</code></pre>

                <p>
                    …the external styles will always win if they collide with the ones provided with <code>:host</code>.
                    So in that case, our element wouldn’t have its background color anymore.
                </p>

                <h2><strong>Theming Using <code>:host-context</code></strong></h2>

                <p>
                    We can also use a <code>:host-context()</code> selector that will select our custom element only if
                    it or any of its ancestors match the provided selector. This makes it really easy to style your
                    element differently if, say, the element has the <code>dark</code> or <code>light</code> class:
                </p>

                <pre>
<code>
:host-context(.dark) {
    background-color: #e65c00;
}

:host-context(.light) {
    background-color: #e65c00;
}
</code></pre>

                <h2><strong>Style Hooks</strong></h2>

                <p>
                    So far we’ve seen how we can easily style a custom element from within, but what if we want to let
                    the user of the element customize the styles without having to modify the element? This is where
                    <code>CSS custom properties come</code> in.
                </p>

                <p>
                    In <code>random-greeter</code>' element’s style definition, you’d use the custom properties like
                    this:
                </p>

                <pre>
<code>
:host {
    ...
    background-color: var(--var-bg-color, #FF6600);
    ...
}

...

h1 {
    ...
    color: var(--var-color, #ffffff);

    @apply --greeter-styles;
}
</code></pre>

                <p>
                    With this in place, our default colors will be used if variables are not defined, and now the colors
                    can be customized in page’s style using something like this:
                </p>

                <pre>
<code>
random-greeter {
    --var-bg-color: navy;
    --var-color: green;

    --greeter-styles: {
        font-family: "Bauhaus 93";
        font-size: 40px;
        border: dotted 5px yellow;
    }
}
</code></pre>

                <h2><strong>Styling distributed nodes</strong></h2>

                <p>
                    <code>::slotted(&lt;compound-selector&gt;)</code> matches nodes that are distributed into a
                    &lt;slot&gt;.
                </p>

                <pre>
<code>
::slotted(marquee) {
    color: yellow;
    font-size: 20px;
}

.bottom::slotted(*) {
    text-align: left;
    color: #ffffff;
}
</code></pre>
            </google-codelab-step>
            <google-codelab-step label="xx" duration="6">
                <aside class="note">
                    <p>
                        We covered the basics of creating custom elements using Web Component specs, but our simple
                        custom element is not yet production-ready because of the use of new JavaScript features and the
                        fact that <strong>Custom Elements</strong> and <strong>Shadow DOM</strong> are not supported in
                        all popular browsers yet.
                    </p>
                </aside>

                <p>
                    In this step, we’ll quickly go over the steps to transpile our custom element code to be compatible
                    with ES5 and to include the necessary Web Components polyfills.
                </p>

                <h2><strong>Transpiling</strong></h2>

                <p>
                    <code>random-greeter</code> element code contains ES6 classes and string literals and arrow
                    functions. These features are great to use at author-time, but the code has to be transpiled using a
                    tool like Babel so that it can run in browsers that only understand ES5 code. We’ll go ahead and use
                    babel-cli and the babel-preset-es2015 preset do to just that.
                </p>

                <p>
                    If your project doesn’t have a <code>package.json</code> file just yet, go ahead an create one using
                    either <code>npm</code> or <code>Yarn</code>. This will allow you to install the necessary
                    packages:
                </p>

                <pre>
<code>
$ npm init

# or, using Yarn
$ yarn init
</code></pre>

                <p>
                    Once this is done, you can go ahead and install the necessary packages:
                </p>

                <pre>
<code>
$ npm install babel-cli babel-preset-es2015 crisper vulcanize rimraf --save-dev

# or, using Yarn
$ yarn add babel-cli babel-preset-es2015 crisper vulcanize rimraf --dev
</code></pre>

                <p>
                    We’ll output our transpiled code into a <code>dist</code> folder, so you can go ahead and create
                    that folder at the root of your project. Now you can some scripts script to the
                    <strong>package.json</strong> file that runs Babel with the es2015 preset and outputs the result in
                    the <strong>dist</strong> folder:
                </p>

                <pre>
<code>
{
    ...
  "scripts": {
    "clean": "rimraf dist",
    "prebuild": "npm run clean -s && mkdir dist",
    "build:vulcanize": "vulcanize random-greeter.html --inline-script --inline-css | crisper -h dist/random-greeter.html -j dist/random-greeter.js",
    "build": "npm run build:vulcanize && babel --presets es2015 dist/random-greeter.js --out-file dist/random-greeter.js"
  },
  "devDependencies": {
    "babel-cli": "^6.26.0",
    "babel-preset-es2015": "^6.24.1",
    "crisper": "^2.1.1",
    "rimraf": "^2.6.2",
    "vulcanize": "^1.16.0"
  }
}
</code></pre>

                <p>
                    Now you can go ahead and run the transpiling:
                </p>

                <pre>
<code>
$ npm run build

# or, using Yarn
$ yarn build
</code></pre>

                <h2><strong>Polyfills</strong></h2>

                <p>
                    Polyfills are small plugins that implement a feature to replace a missing native implementation for
                    browsers that don’t have support yet. For Web Components, we’ll need polyfills for Custom Elements,
                    Shadow DOM and the template element.
                </p>

                <p>
                    There’s also a loader available, <code>webcomponents-loader.js</code>, that will perform some
                    feature detection and include the necessary polyfills on the fly. Using the loader is probably the
                    simplest way to get everything working, and this is what we’ll use here for our example.
                </p>

                <p>
                    Custom elements need to be defined using ES6 classes that extend <code>HTMLElement</code>, but now
                    we’re using transpiled code that has the class syntax stripped away. We’ll need to use a file called
                    <code>custom-elements-es5-adapter.js</code> to fix that for us.
                </p>

                <p>
                    Simply install the <code>@webcomponents/webcomponentsjs</code> package into your project using
                    <code>npm</code> or <code>yarn</code>. This will install the necessary files in the node_modules
                    folder:
                </p>

                <pre>
<code>
$ npm install @webcomponents/webcomponentsjs --save

# or, using Yarn
$ yarn add npm install @webcomponents/webcomponentsjs
</code></pre>

                <p>
                    Now, in your page’s head, include <code>custom-elements-es5-adapter.js</code> and
                    <code>webcomponents-loader.js</code>:
                </p>

                <pre>
<code>
&lt;script src="node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js"&gt;&lt;/script&gt;
&lt;script src="node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"&gt;&lt;/script&gt;
</code></pre>

                <p>
                    The final step is only include the script for your transpiled custom element when the <code>WebComponentsReady</code>
                    event fires. That’s a custom event that gets fired by the loader when the necessary polyfills have
                    been loaded. We’ll simply create a <code>link</code> element, set its <code>rel</code> and <strong>src</strong>
                    property to the path of our transpiled custom element code and append it to the document’s head:
                </p>

                <pre>
<code>
window.addEventListener('WebComponentsReady', function () {
    var randomGreeterImport = document.createElement('link');
    randomGreeterImport.rel = 'import';
    randomGreeterImport.href = 'dist/random-greeter.html';
    document.head.appendChild(randomGreeterImport);
});
</code></pre>

                <p>
                    Here’s how our final <code>index.html</code> file looks like:
                </p>

                <pre>
<code>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Web Component Basics&lt;/title&gt;

        &lt;script src="node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js"&gt;&lt;/script&gt;
        &lt;script src="node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"&gt;&lt;/script&gt;
        &lt;style&gt;
            h1 {
                color: #ff6600 !important;
            }

            random-greeter {
                --var-bg-color: navy;
                --var-color: green;

                --greeter-styles: {
                    font-family: "Bauhaus 93";
                    font-size: 40px;
                    border: dotted 5px yellow;
                }
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;random-greeter class="light"&gt;&lt;/random-greeter&gt;
        &lt;random-greeter class="dark"&gt;&lt;/random-greeter&gt;
        &lt;random-greeter&gt;
            &lt;marquee behavior="alternate" direction="right" slot="top"&gt;#BBConf rulz!!!&lt;/marquee&gt;
            &lt;ul&gt;
                &lt;li&gt;Something&lt;/li&gt;
                &lt;li&gt;More something&lt;/li&gt;
                &lt;li&gt;About&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/random-greeter&gt;

        &lt;script&gt;
            window.addEventListener('WebComponentsReady', function () {
                var randomGreeterImport = document.createElement('link');
                randomGreeterImport.rel = 'import';
                randomGreeterImport.href = 'dist/random-greeter.html';
                document.head.appendChild(randomGreeterImport);
            });
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
            </google-codelab-step>
            <google-codelab-step label="xx" duration="1">
                <p>
                    Custom elements allow you to extend HTML and define your own tags. They're an incredibly powerful
                    feature, but they're also low-level, which means it's not always clear how best to implement your
                    own element
                </p>

                <p>
                    Here is a checklist which breaks down the things we applied to create a well behaved custom element.
                </p>

                <ul class="checklist">
                    <li>Create a shadow root to encapsulate styles.</li>
                    <li>Create your shadow root in the constructor.</li>
                    <li>Place any children the element creates into its shadow root.</li>
                    <li>
                        Set a :host display style (e.g. block, inline-block, flex) unless you prefer the default of
                        inline.
                    </li>
                    <li>Add a :host display style that respects the hidden attribute.</li>
                    <li>
                        Always accept primitive data (strings, numbers, booleans) as either attributes or properties.
                    </li>
                    <li>
                        Aim to keep primitive data attributes and properties in sync, reflecting from property to
                        attribute, and vice versa.
                    </li>
                    <li>Aim to only accept rich data (objects, arrays) as properties.</li>
                    <li>Do not reflect rich data properties to attributes.</li>
                </ul>
            </google-codelab-step>
        </google-codelab>
    </template>
    <script>
        Polymer({
            is: 'codelab-simple-card-component',

            _twoWayBinding: function(value) {
                return '{{' + value + '}}';
            },

            _oneWayBinding: function(value) {
                return '[[' + value + ']]';
            }
        });
    </script>
</dom-module>
